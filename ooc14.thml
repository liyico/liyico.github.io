
14
Forwarding Messages A GUI Calculator

In this chapter we look at a rather typical problem: one object hierarchy we build ourselves to create an application, and another object hierarchy is more or less imposed upon us, because it deals with system facilities such as a graphical user interface (GUI, the pronunciation indicates the generally charming qualities). At this point, real programmers turn to multiple inheritance, but, as our example of the obli- gatory moused calculator demonstrates, an elegant solution can be had at a fraction of the cost.

14.1The Idea
Every dynamically linked method is called through its selector, and we saw in chapter 8 that the selector checks if its method can be found for the object. As an example, consider the selector add() for the method to add an object to a List:
struct Object * add (void * _self, const void * element) { struct Object * result;
const struct ListClass * class =
cast(ListClass(), classOf(_self));
assert(class —> add.method); cast(Object(), element);
result = ((struct Object * (*) ())
class —> add.method)(_self, element);
return result;
}
classOf() tries to make sure that _self references an object; the surrounding call to cast() ascertains that the class description of _self belongs to the metaclass ListClass, i.e., that it really contains a pointer to an add method; finally, assert() guards against a null value masquerading as this pointer, i.e., it makes sure that an add method has been implemented somewhere up the inheritance chain.
What happens if add() is applied to an object that has never heard of this method, i.e., what happens if _self flunks the various tests in the add() selector? As it stands, an assert() gets triggered somewhere, the problem is contained, and our program quits.
Suppose we are working on a class X of objects which themselves are not des- cendants of List but which know some List object to which they could logically pass a request to add(). As it stands, it would be the responsibility of the user of X objects, to know (or to find out with respondsTo()) that add() cannot be applied to them and to reroute the call accordingly. However, consider the following, slightly revised selector:


struct Object * add (void * _self, const void * element) { struct Object * result;
const struct ListClass * class =
(const void *) classOf(_self);
if (isOf(class, ListClass()) && class —> add.method) { cast(Object(), element);
result = ((struct Object * (*) ())
class —> add.method)(_self, element);
} else
forward(_self, & result, (Method) add, "add",
_self, element);
return result;
}
Now, _self can reference any object. If its class happens to contain a valid add pointer, the method is called as before. Otherwise, all the information is passed to a new method forward(): the object itself; an area for the expected result; a pointer to and the name of the selector which failed; and the values in the original argu- ment list. forward() is itself a dynamically linked method declared in Object:
% Class Object {
...
%—
void forward (const _self, void * result, \ Method selector, const char * name, ...);
Obviously, the initial definition is a bit helpless:
% Object forward {
%casts
fprintf(stderr, "%s at %p does not answer %s\n",
nameOf(classOf(self)), self, name);
assert(0);
}
If an Object itself does not understand a method, we are out of luck. However, forward() is dynamically linked: if a class wants to forward messages, it can accomplish this by redefining forward(). As we shall see in the example in section 14.6, this is almost as good as an object belonging to several classes at the same time.

14.2Implementation
Fortunately, we decided in chapter 7 to enforce our coding standard with a prepro- cessor ooc, and selectors are a part of the coding standard. In section 8.4 we looked at the selector report which generates all selectors. Message forwarding is accomplished by declaring forward() as shown above, by defining a default imple- mentation, and by modifying the selector report in etc.rep so that all generated selectors reroute what they do not understand:*

*As before, the presentation is simplified so that it does not show the parts which deal with variable argument lists.

14.2 Implementation

169



`%header { `n
`%result
`%classOf
`%ifmethod
`%checks
`%call
`t } else `n
`%forward
`%return
} `n `n
This is almost the same code as in section 8.4: as we saw above, the cast() in the classOf report is turned into a call to isOf() as part of the ifmethod report and an else clause is added with the forward report to generate the call to forward().
The call to forward() is routed through another selector for argument checking. It is probably not helpful to get stuck in recursion here, so if the selector forward() itself is generated, we stop things with an assert():
% forward	// forward the call, but don’t forward forward
`{if `method forward
`t `t assert(0);
`} `{else
`t `t forward(_self, \
`{if `result void 0, `} `{else & result, `} \ (Method) `method , " `method ", `%args );
`} `n
The additional `{if concerns the fact that a selector eventually has to return the result expected by its caller. This result will have to be produced by forward(). The general approach is to pass the result area to forward() to get it filled somehow. If, however, our selector returns void, we have no result variable. In this case we pass a null pointer.
It looks as if we could write slightly better code by hand: in some cases we could avoid the result variable, assignment, and a separate return statement. However, tuning would complicate the ooc reports unnecessarily because any rea- sonable compiler will generate the same machine code in either case.
classOf is the other report that gets modified significantly. A call to cast() is removed, but the interesting question is what happens if a call to a class method needs to be forwarded. Let us look at the selector which ooc generates for new():
struct Object * new (const void * _self, ...) { struct Object * result;
va_list ap;
const struct Class * class = cast(Class(), _self);
va_start(ap, _self);
if (class —> new.method) {
result = ((struct Object * (*) ()) class —> new.method)
(_self, & ap);


} else
forward((void *) _self, & result, (Method) new, "new",
_self, & ap);
va_end(ap); return result;
}
new() is called for a class description like List. Calling a class method for something other than a class description is probably a very bad idea; therefore, cast() is used to forbid this. new belongs into Class; therefore, no call to isOf() is needed.
Let’s assume that we forgot to define the initial Object_new(), i.e., that List has not even inherited a new method, and that, therefore, new.method is a null pointer. In this case, forward() is applied to List. However, forward() is a dynami- cally linked method, not a class method. Therefore, forward() looks in the class description of List for a forward method, i.e., it tries to find ListClass_forward():


aList

List

ListClass



struct ListClass

This is perfectly reasonable: List_forward() is responsible for all messages which aList does not understand; ListClass_forward() is responsible for all those which List cannot handle. Here is the classOf report in etc.rep:
`{if `linkage %—
`{if `meta `metaroot
`t const struct `meta * class = classOf(_self); `n
`} `{else
`t const struct `meta * class = ` \
(const  void *) classOf(_self); `n
`}


`} `{else
`t const struct `meta * class = ` \
cast( `metaroot (), _self); `n
`} `n
For dynamically linked methods `linkage is %. In this case we get the class description as a struct Class from classOf(), but we cast it to the class description structure which it will be once isOf() has verified the type, so that we can select the appropriate method component.
For a class method, `linkage evaluates as %+, i.e., we advance to the second half of the report and simply check with cast() that _self is at least a Class. This is the only difference in a selector for a class method with forwarding.

14.3Object-Oriented Design by Example
GUIs are everybody’s favorite demonstration ground for the power of object-oriented approaches. A typical benchmark is to create a small calculator that can be operated with mouse clicks or from the keyboard:

We will now build such a calculator for the curses and X11 screen managers. We use an object-oriented approach to design, implement, and test a general solution. Once it works, we connect it to two completely incompatible graphical environ- ments. In due course, we shall see how elegantly message forwarding can be used.
It helps to get the application’s algorithm working, before we head for the GUI library. It also helps to decompose the application’s job into interacting objects. Therefore, let us just look at what objects we can identify in the calculator pictured above.
Our calculator has buttons, a computing chip, and a display. The display is an information sink: it receives something and displays it. The computing chip is an information filter: it receives something, changes its own state, and passes modi- fied information on. A button is an information source or even a filter: if it is prop- erly stimulated, it will send information on.
Thus far, we have identified at least four classes of objects: the display, the computing chip, buttons, and information passed between them. There may be a fifth kind of object, namely the source of the stimulus for a button, which models our keyboard, a mouse, etc.


There is a common aspect that fits some of these classes: a display, comput- ing chip, or button may be wired to one next object, and the information is transmit- ted along this wire. An information sink like the display only receives information, but that does not hurt the general picture. So far, we get the following design:

CLASS	DATA	METHODS	
Object			base class
Event	
kind		information to pass type of data
	data		text, position, etc.
Ic	
out	

wire	base class for application object I am connected to connect me to another object
		gate	send information to out
LineOut		
wire	model the display not used
		gate	display incoming information
Button	
text	

gate	model an input device
label, defines interesting information look at incoming information:
if it matches text, send it on
Calc	
state	

gate	computing chip current value, etc.
change state based on information, pass new current value on, if any
This looks good enough for declaring the principal methods and trying to write a main program to test the decomposition of our problem world into classes.
Ic.d
enum react { reject, accept };
% IcClass: Class Ic: Object { void * out;
%—
void wire (Object @ to, _self);
enum react gate (_self, const void * item);
%}
% IcClass LineOut: Ic {
%}
% IcClass Button: Ic { const char * text;
%}


run.c
int main ()
{	void * calc = new(Calc());
void * lineOut = new(LineOut()); void * mux = new(Mux());
static const char * const cmd [] = { "C", "Q",
"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "—", "*", "/", "=", 0 };
const char * const * cpp;
wire(lineOut, calc);
for (cpp = cmd; * cpp; ++ cpp)
{	void * button = new(Button(), * cpp);
wire(calc, button), wire(button, mux);
}
Close. We can set up a computing chip, a display, and any number of buttons, and connect them. However, if we want to test this setup with character input from a keyboard, we will have to wrap every character as an Event and offer it to each Button until one is interested and returns accept when we call its gate() method. One more class would help:

CLASS	DATA	METHODS	
Object			base class
Ic			base class for application
Mux	
list	

wire	multiplexer, one input to many outputs
List of objects
connects me to another object
		gate	passes information until some object wants it
The main program shown above already uses a Mux object and connects it to each
Button. We are ready for the main loop:
while ((ch = getchar()) != EOF) if (! isspace(ch))
{	static char buf [2]; void * event;
buf[0] = ch;
gate(mux, event = new(Event(), 0, buf)); delete(event);
}
return 0;
}
White space is ignored. Every other character is wrapped as an Event with kind zero and the character as a string. The event is handed to the multiplexer and the computation takes its course.


Summary
This design was motivated by the Class-Responsibility-Collaborator technique described in [Bud91]: We identify objects more or less by looking at the problem. An object is given certain responsibilities to carry out. This leads to other objects which collaborate in carrying out the work. Once the objects are known, they are collected into classes and, hopefully, a hierarchical pattern can be found that is deeper than just one level.
The key idea for this application is the Ic class with the capability of receiving, changing, and routing information. This idea was inspired by the Interface Builder of NeXTSTEP where much of the information flow, even to application-specific classes, can be ‘‘wired’’ by mouse-dragging when the graphical user interface is designed with a graphics editor.

14.4Implementation — Ic
Obviously, gate() is a dynamically bound method, because the subclasses of Ic use it to receive and process information. Ic itself owns out, the pointer to another object to which information must be sent. Ic itself is mostly an abstract base class, but Ic_gate() can access out and actually pass information on:
% Ic gate {
%casts
return self —> out ? gate(self —> out, item) : reject;
}
This is motivated by information hiding: if a subclass’ gate method wants to send information on, it can simply call super_gate().
wire() is trivial: it connects an Ic to another object by storing the object address in out:
% Ic wire {
%casts
self —> out = to;
}
Once the multiplexer class Mux is invented, we realize that wire(), too, must be dynamically linked. Mux overwrites wire() to add its target object to a List:
% Mux wire {	// add another receiver
%casts
addLast(self —> list, to);
}
Mux_gate() can be defined in various ways. Generally, it has to offer the incoming information to some target objects; however, we can still decide in which order we do this and whether or not we want to quit once an object accepts the information
— there is room for subclasses!


% Mux gate {	// sends to first responder unsigned i, n;
enum react result = reject;
%casts
n = count(self —> list); for (i = 0; i < n; ++ i)
{	result = gate(lookAt(self —> list, i), item); if (result == accept)
break;
}
return result;
}
This solution proceeds sequentially through the list in the order in which it was created, and it quits as soon as one invocation of gate() returns accept.
LineOut is needed so that we can test a computing chip without connecting it to a graphical user interface. gate() has been defined leniently enough so that LineOut_gate() is little more than a call to puts():
% LineOut gate {
%casts
assert(item);
puts(item);	// hopefully, it is a string return accept;
}
Of course, LineOut would be more robust, if we used a String object as input.
The classes built thus far can actually be tested. The following example hello connects an Ic to a Mux and from there first to two more Ic objects and then twice to a LineOut. Finally, a string is sent to the first Ic:
int main ()
{	void * ic = new(Ic()); void * mux = new(Mux()); int i;
void * lineOut = new(LineOut());
for (i = 0; i < 2; ++ i) wire(new(Ic()), mux);
wire(lineOut, mux); wire(lineOut, mux); wire(mux, ic); puto(ic, stdout);
gate(ic, "hello, world"); return 0;
}
The output shows the connections described by puto() and the string displayed by the LineOut:


$ hello
Ic at 0x182cc
wired to Mux at 0x18354 wired to [nil]
list List at 0x18440
dim 4, count 4 {
Ic at 0x184f0 wired to [nil] Ic at 0x18500 wired to [nil]
LineOut at 0x184e0 wired to [nil]
LineOut at 0x184e0 wired to [nil]
}
hello, world
Although the Mux object is connected to the LineOut object twice, hello, world is output only once, because the Mux object passes its information only until some gate() returns accept.
Before we can implement Button we have to make a few assumptions about the Event class. An Event object contains the information that is normally sent from one Ic to another. Information from the keyboard can be represented as a string, but a mouse click or a cursor position looks different. Therefore, we let an Event contain a number kind to characterize the information and a pointer data which hides the actual values:
% Event ctor { // new(Event(), 0, "text") etc.
struct Event * self = super_ctor(Event(), _self, app);
self —> kind = va_arg(* app, int); self —> data = va_arg(* app, void *); return self;
}
Now we are ready to design a Button as an information filter: if the incoming Event is a string, it must match the button’s text; any other information is accepted sight unseen, as it should have been checked elsewhere already. If the Event is accepted, Button will send its text on:
% Button ctor {	// new(Button(), "text")
struct Button * self = super_ctor(Button(), _self, app);
self —> text = va_arg(* app, const char *); return self;
}
% Button gate {
%casts
if (item && kind(item) == 0
&& strcmp(data(item), self —> text)) return reject;
return super_gate(Button(), self, self —> text);
}


This, too, can be checked with a small test program button in which a Button is wired to a LineOut:
int main ()
{	void * button, * lineOut; char buf [100];
lineOut = new(LineOut()); button = new(Button(), "a"); wire(lineOut, button); while (gets(buf))
{	void * event = new(Event(), 0, buf);
if (gate(button, event) == accept) break;
delete(event);
}
return 0;
}
button ignores all input lines until a line contains the a which is the text of the but- ton:
$ button ignore
a
a
Only one a is input, the other one is printed by the LineOut.
LineOut and Button were implemented mostly to check the computing chip before it is connected to a graphical interface. The computing chip Calc can be as complicated as we wish, but for starters we stick with a very primitive design: digits are assembled into a value in the display; the arithmetic operators are exe- cuted as soon as possible without precedence; = produces a total; C clears the current value; and Q terminates the program by calling exit(0);.
This algorithm can be executed by a finite state machine. A practical approach uses a variable state as an index selecting one of two values, and a variable op to remember the current operator which will be applied after the next value is com- plete:
%prot
typedef int values[2];	// left and right operand stack
% IcClass Calc: Ic {
values value;	// left and right operand
int op;	// operator
int state;	// FSM state
%}


The following table summarizes the algorithm that has to be coded:

input	state	value[]	op	super_gate()
digit	any	v[any] *= 10 v[any] += digit		
value[any]

+ - * /	0  1	v[1] = 0	input	
	1	v[0] op= v[1] v[1] = 0	input	value[0]

=	0	v[0] = 0		
	1  0	v[0] op= v[1] v[0] = 0		value[0]
C	any	v[any] = 0		value[any]
And it really works:
$ run
12 + 34 * 56 = Q
1
12
3
34
46
5
56
2576
Summary
The Ic classes are very simple to implement. A trivial LineOut and an input loop, which reads from the keyboard, enable us to check Calc before it is inserted into a complicated interface.
Calc communicates with its input buttons and output display by calling gate(). This is coupled loosely enough so that Calc can send fewer (or even more) mes- sages to the display than it receives itself.
Calc operates very strictly bottom-up, i.e., it reacts to every input passed in through Calc_gate(). Unfortunately, this rules out the recursive descent technique introduced in the third chapter, or other syntax-driven mechanisms such as yacc grammars, but this is a characteristic of the message-based design. Recursive des- cent and similar mechanisms start from the main program down, and they decide when they want to look at input. In contradistinction, message-driven applications use the main program as a loop to gather events, and the objects must react to these events as they are sent in.
If we insist on a top-down approach for Calc, we must give it its own thread of control, i.e., it must be a coroutine, a thread under Mach and similar systems, or even another process under UNIX, and the message paradigm must be subverted by process communication.


14.5A Character-Based Interface — curses
curses is an ancient library, which manages character-based terminals and hides the idiosyncracies of various terminals by using the termcap or terminfo databases [Sch90]. Originally, Ken Arnold at Berkeley extracted the functions from Bill Joy’s vi editor. Meanwhile, there are several, optimized implementations, even for DOS; some are in the public domain.
If we want to connect our calculator to curses, we have to implement replace- ments for LineOut and Button and connect them with a Calc object. curses pro- vides a WINDOW data type, and it turns out that our best bet is to use a WINDOW for each graphical object. The original version of curses does not use a mouse or even provide functions to move a cursor under control of something like arrow keys. Therefore, we will have to implement another object that runs the cursor and sends cursor positions as events to the buttons.
It looks like we have two choices. We can define a subclass of Ic to manage the cursor and the main loop of the application, and subclasses of Button and of LineOut to provide the graphical objects. Every one of these three classes will own its own WINDOW. Alternatively, as shown at right below, we can start a new hierar- chy with a subclass of Ic which owns a WINDOW and can run the cursor. Addition- ally we create two more subclasses which then may have to own a Button and a LineOut, respectively.
Object	Object
Ic	Ic
Button	Button
CButton
LineOut	LineOut CLineOut
Crt	Crt
CButton CLineOut
Neither solution looks quite right. The first one seems perhaps closer to our appli- cation, but we don’t encapsulate the existence of the WINDOW data type in a single class, and it does not look like we package curses in a way that can be reused for the next project. The second solution seems to encapsulate curses mostly in Crt; however, the subclasses need to contain objects that are very close to the applica- tion, i.e., once again we are likely to end up with a once-only solution.
Let us stick with the second approach. We will see in the next section how we can produce a better design with message forwarding. Here are the new classes:


CLASS	DATA	METHODS	
Object		base class
Ic		base class for application
Crt		base class for screen management
	window	curses WINDOW
	rows, cols
makeWindow	size
create my window
		addStr	display a string in my window
		crtBox	run a frame around my window
		gate	run cursor, send text or positions
CLineOut			output window
		gate	display text in my window
CButton			box with label to click
	button		a Button to accept and forward events
	x, y		my position
		gate	if text event, send to button
			if position event matches,
			send null pointer to button
Implementing these classes requires a certain familiarity with curses; therefore, we will not look at the details of the code here. The curses package has to be initial- ized; this is taken care of by a hook in Crt_ctor(): the necessary curses functions are called when the first Crt object is created.
Crt_gate() contains the main loop of the program. It ignores its incoming event and it reads from the keyboard until it sees a control-D as an end of input indication. At this point it will return reject and the main program terminates.
A few input characters are used to control the cursor. If return is pressed, Crt_gate() calls super_gate() to send out an event with kind one and with an integer array with the current row and column position of the cursor. All other char- acters are sent out as events with kind zero and the character as a string.
The interesting class is CButton. When an object is constructed, a box appears on the screen with the button name inside.
% CButton ctor {	// new(CButton(), "text", row, col)
struct CButton * self = super_ctor(CButton(), _self, app);
self —> button =
new(Button(), va_arg(* app, const char *)); self —> y = va_arg(* app, int);
self —> x = va_arg(* app, int);
makeWindow(self, 3, strlen(text(self —> button)) + 4,
self —> y, self —> x); addStr(self, 1, 2, text(self —> button)); crtBox(self);
return self;
}


The window is created large enough for the text surrounded by spaces and a frame.
wire() must be overwritten so that the internal button gets connected:
% CButton wire {
%casts
wire(to, self —> button);
}
Finally, CButton_gate() passes text events directly on to the internal button. For a position event we check if the cursor is within our own box:
% CButton gate {
%casts
if (kind(item) == 1)	// kind == 1 is click event
{	int * v = data(item);	// data is an array [x, y]
if (v[0] >= self —> x && v[0] < self —> x + cols(self) && v[1] >= self —> y && v[1] < self —> y + rows(self))
return gate(self —> button, 0); return reject;
}
return gate(self —> button, item);
}
If so, we send a null pointer to the internal button which responds by sending on its own text.
Once again, we can check the new classes with a simple program cbutton
before we wire up the entire calculator application.
int main ()
{	void * crt = new(Crt());
void * lineOut = new(CLineOut(), 5, 10, 40); void * button = new(CButton(), "a", 10, 40);
makeWindow(crt, 0, 0, 0, 0);	/* total screen */ gate(lineOut, "hello, world");
wire(lineOut, button), wire(button, crt); gate(crt, 0);	/* main loop */
return 0;
}
This program displays hello, world on the fifth line and a small button with the label a near the middle of our terminal screen. If we move the cursor into the button and press return, or if we press a, the display will change and show the a. cbutton ends if interrupted or if we input control-D.
Once this works, our calculator will, too. It just has more buttons and a com- puting chip:
int main ()
{	void * calc = new(Calc()); void * crt = new(Crt());
void * lineOut = new(CLineOut(), 1, 1, 12); void * mux = new(Mux());


static const struct tbl { const char * nm; int y, x; } tbl [] = {	"C", 0, 15,
"1", 3, 0, "2", 3, 5, "3", 3, 10, "+", 3, 15,
"4", 6, 0, "5", 6, 5, "6", 6, 10, "—", 6, 15,
"7", 9, 0, "8", 9, 5, "9", 9, 10, "*", 9, 15,
"Q", 12, 0, "0", 12, 5, "=", 12, 10, "/", 12, 15,
0 };
const struct tbl * tp;
makeWindow(crt, 0, 0, 0, 0); wire(lineOut, calc); wire(mux, crt);
for (tp = tbl; tp —> nm; ++ tp)
{	void * o = new(CButton(), tp —> nm, tp —> y, tp —> x);
wire(calc, o), wire(o, mux);
}
gate(crt, 0);
return 0;
}
The solution is quite similar to the last one. A CButton object needs coordinates; therefore, we extend the table from which the buttons are created. We add a Crt object, connect it to the multiplexer, and let it run the main loop.
Summary
It should not come as a great surprise that we reused the Calc class. That is the least we can expect, no matter what design technique we use for the application. However, we also reused Button, and the Ic base class helped us to concentrate totally on coping with curses rather than with adapting the computing chip to a dif- ferent variety of inputs.
The glitch lies in the fact, that we have no clean separation between curses and the Ic class. Our class hierarchy forces us to compromise and (more or less) use two Ic objects in a CButton. If the next project does not use the Ic class, we can- not reuse the code developed to hide the details of curses.

14.6A Graphical Interface — Xt
The X Window System (X11) is the de facto standard for graphical user interfaces on UNIX and other systems.* X11 controls a terminal with a bitmap screen, a mouse, and a keyboard and provides input and output facilities. Xlib is a library of functions implementing a communication protocol between an application program and the X11 server controlling the terminal.



*The standard source for information about X11 programming is the X Window System series published by O’Reilly and Associates. Background material for the current section can be found in volume 4, manual pages are in volume 5, ISBN 0-937175-58-7.


X11 programming is quite difficult because application programs are expected to behave responsibly in sharing the facilities of the server. Therefore, there is the X toolkit, a small class hierarchy which mostly serves as a foundation for libraries of graphical objects. The toolkit is implemented in C. Toolkit objects are called wid- gets.
The base class of the toolkit is Object, i.e., we will have to fix our code to avoid that name. Another important class in the toolkit is ApplicationShell: a widget from this class usually provides the framework for a program using the X11 server.
The toolkit itself does not contain classes with widgets that are visible on the screen. However, Xaw, the Athena Widgets, are a generally available, primitive extension of the toolkit class hierarchy which provides enough functionality to demonstrate our calculator.
The widgets of an application program are arranged in a tree. The root of this tree is an ApplicationShell object. If we work with Xaw, a Box or Form widget is next, because it is able to control further widgets within its screen area. For our calculator display we can use a Label widget from Xaw, and a button can be imple- mented with a Command widget.
On the screen, the Command widget appears as a frame with a text in it. If the mouse enters or leaves the frame, it changes its visual appearance. If a mouse button is clicked inside the frame, the widget will invoke a callback function which must have been registered previously.
So-called translation tables connect events such as mouse clicks and key presses on the keyboard to so-called action functions connected with the widget at which the mouse currently points. Command has action functions which change its visual appearance and cause the callback function to be invoked. These actions are used in the Command translation table to implement the reaction to a mouse click. The translation tables of a particular widget can be changed or augmented, i.e., we can decide that the key press 0 influences a particular Command widget as if a mouse button had been clicked inside its frame.
So-called accelerators are essentially redirections of translation tables from one widget to another. Effectively, if the mouse is inside a Box widget, and if we press a key such as +, we can redirect this key press from the Box widget to some Com- mand widget inside the box, and recognize it as if a mouse button had been clicked inside the Command widget itself.
To summarize: we will need an ApplicationShell widget as a framework; a Box or Form widget to contain other widgets; a Label widget as a display; several Command widgets with suitable callback functions for our buttons; and certain magical convolutions permit us to arrange for key presses to cause the same effects as mouse clicks on specific Command widgets.
The standard approach is to create classes of our own to communicate with the classes of the toolkit hierarchy. Such classes are usually referred to as wrappers for a foreign hierarchy or system. Obviously, the wrappers should be as indepen- dent of any other considerations as possible, so that we can use them in arbitrary


toolkit projects. In general, we should wrap everything in the toolkit; but, to keep this book within reason, here is the minimal set for the calculator:

CLASS	DATA   METHODS

Objct	our base class (renamed)
Xt	base class for X toolkit wrappers
widget		my X toolkit widget makeWidget	create my widget addAllAccelerators
setLabel	change label resource
addCallback	add callback function
(widget may or may not change)

XtApplicationShell	
mainLoop	framework
X11 event loop
XawBox XawForm XawLabel XawCommand		wraps Athena’s Box wraps Athena’s Form wraps Athena’s Label wraps Athena’s Command
These classes are very simple to implement. They exist mostly to hide the uglier X11 and toolkit incantation from our own applications. There are some design choices. For example, setLabel() could be defined for XawLabel rather than for Xt, because a new label is only meaningful for XawLabel and XawCommand but not for ApplicationShell, Box, or Form. However, by defining setLabel() for Xt we model how the toolkit works: widgets are controlled by so-called resources which can be supplied during creation or later by calling XtSetValues(). It is up to the wid- get if it knows a particular resource and decides to act when it receives a new value for it. Being able to send the value is a property of the toolkit as such, not of a par- ticular widget.
Given this foundation, we need only two more kinds of objects: an XLineOut receives a string and displays it and an XButton sends out text events for mouse clicks or keyboard characters. XLineOut is a subclass of XawLabel which behaves like a LineOut, i.e., which must do something about gate().
Xt.d



Xt.dc

% Class XLineOut: XawLabel {
%}

% XLineOut ctor {	// new(XLineOut(), parent, "name", "text") struct XLineOut * self =
super_ctor(XLineOut(), _self, app); const char * text = va_arg(* app, const char *);
gate(self, text); return self;

}


Three arguments must be specified when an XLineOut is created: the superclass constructor needs a parent Xt object which supplies the parent widget for the application’s widget hierarchy; the new widget should be given a name for the qual- ification of resource names in an application default file; and, finally, the new XLineOut is initially set to some text which may imply its size on the screen. The constructor is brave and simply uses gate() to send this initial text to itself.
Because XLineOut does not descend from Ic, it cannot respond directly to gate(). However, the selector will forward the call; therefore, we overwrite for- ward() to do the work that would be done by a gate method if XLineOut could have one:
% XLineOut forward {
%casts
if (selector == (Method) gate)
{	va_arg(* app, void *);
setLabel((void *) self, va_arg(* app, const void *));
* (enum react *) result = accept;

}
else


}



super_forward(XLineOut(), _self, result,
selector, name, app);

We cannot be sure that every call to XLineOut_forward() is a gate() in dis- guise. Every forward method should check and only respond to expected calls. The others can, of course, be forwarded up along the inheritance chain with super_forward().
Just as for new(), forward() is declared with a variable argument list; however, the selector can only pass an initialized va_list value to the actual method, and the superclass selector must receive such a pointer. To simplify argument list sharing, specifically in deference to the metaclass constructor, ooc generates code to pass a pointer to an argument list pointer, i.e., the parameter va_list * app.
As a trivial example for forwarding the gate() message to an XLineOut, here is the xhello test program:
void main (int argc, char * argv [])
{	void * shell = new(XtApplicationShell(), & argc, argv); void * lineOut = new(XLineOut(), shell, 0, "hello, world");
mainLoop(shell);
}
The program displays a window with the text hello, world and waits to be killed with a signal. Here, we have not given the widget in the XLineOut object an expli- cit name, because we are not specifying any resources.
XButton is a subclass of XawCommand so that we can install a callback func- tion to receive mouse clicks and key presses:



Xt.d



% Class XButton: XawCommand { void * button;


Xt.dc

%}

% XButton ctor {	// new(XButton(), parent, "name", "text") struct XButton * self = super_ctor(XButton(), _self, app); const char * text = va_arg(* app, const char *);
self —> button = new(Button(), text); setLabel(self, text);
addCallback(self, tell, self —> button); return self;

}
XButton has the same construction arguments as XLineOut: a parent Xt object, a widget name, and the text to appear on the button. The widget name may well be different from the text, e.g., the operators for our calculator are unsuitable as com- ponents in resource path names.
The interesting part is the callback function. We let an XButton own a Button
and arrange for the callback function tell() to send a null pointer with gate() to it:
static void tell (Widget w, XtPointer client_data,
XtPointer call_data)
{
gate(client_data, NULL);
}
client_data is registered with the callback function for the widget to pass it in later. We use it to designate the target of gate().
We could actually avoid the internal button, because we could set up XButton itself to be wired to some other object; client_data could point to a pointer to this target and a pointer to the text, and then tell() could send the text directly to the target. It is simpler, however, to reuse the functionality of Button, especially, because it opens up the possibility for XButton to receive text via a forwarded gate() and pass it to the internal Button for filtering.
Message forwarding is, of course, the key to XButton as well: the internal but- ton is inaccessible, but it needs to respond to a wire() that is originally directed at an XButton:
% XButton forward {
%casts
if (selector == wire)
wire(va_arg(* app, void *), self —> button);

else


}


super_forward(XButton(), _self, result,
selector, name, app);


Comparing the two forward methods we notice that forward() receives self with the const qualifier but circumvents it in the case of XLineOut_forward(). The basic idea is that the implementor of gate() must know if this is safe.
Once again, we can test XButton with a simple program xbutton. This program places an XLineOut and an XButton into an XawBox and another pair into an XawForm. Both containers are packed into another XawBox:
void main (int argc, char * argv [])
{	void * shell = new(XtApplicationShell(), & argc, argv); void * box = new(XawBox(), shell, 0);
void * composite = new(XawBox(), box, 0);
void * lineOut = new(XLineOut(), composite, 0, "—long—"); void * button = new(XButton(), composite, 0, "a");
wire(lineOut, button);
puto(button, stdout);	/* Box will move its children */
composite = new(XawForm(), box, "form");
lineOut = new(XLineOut(), composite,"lineOut", "—long—"); button = new(XButton(), composite, "button", "b");
wire(lineOut, button);
puto(button, stdout);	/* Form won’t move its children */
mainLoop(shell);
}
The result appears approximately as follows on the screen:

Once the button a is pressed in the top half, the XLineOut receives and displays the text a. The Athena Box widget used as a container will resize the Label widget, i.e., the top box changes to display two squares, each with the text a inside. The button with text b is contained in an Athena Form widget, where the resource
*form.button.fromHoriz: lineOut
controls the placement. The Form widget maintains the appearance of the bottom rectangle even when b is pressed and the short text b appears inside the XLineOut.
The test program demonstrates that XButton can operate with mouse clicks and wire(); therefore, it is time to wire the calculator xrun:


void main (int argc, char * argv [])
{	void * shell = new(XtApplicationShell(), & argc, argv); void * form = new(XawForm(), shell, "form");
void * lineOut = new(XLineOut(), form, "lineOut",
"........");
void * calc = new(Calc());
static const char * const cmd [] = { "C", "C", "1", "1", "2", "2", "3", "3", "a", "+",
"4", "4", "5", "5", "6", "6", "s", "—",
"7", "7", "8", "8", "9", "9", "m", "*",
"Q", "Q", "0", "0", "t", "=", "d", "/", 0 };
const char * const * cpp;
wire(lineOut, calc);
for (cpp = cmd; * cpp; cpp += 2)
{	void * button = new(XButton(), form, cpp[0], cpp[1]);
wire(calc, button);
}
addAllAccelerators(form); mainLoop(shell);
}
This program is even simpler than the curses version, because the table only con- tains the name and text for each button. The arrangement of the buttons is han- dled by resources:
*form.C.fromHoriz:	lineOut
*form.1.fromVert:	lineOut
*form.2.fromVert:	lineOut
*form.3.fromVert:	lineOut
*form.a.fromVert:	C
*form.2.fromHoriz:	1
*form.3.fromHoriz:	2
*form.a.fromHoriz:	3
...
The resource file also contains the accelerators which are loaded by addAllAc- celerators():

*form.C.accelerators:	<KeyPress>c:	set()	notify()	unset()
*form.Q.accelerators:	<KeyPress>q:	set()	notify()	unset()
*form.0.accelerators:	:<KeyPress>0:	set()	notify()	unset()
...				
If the resources are in a file Xapp, the calculator can, for example, be started with the following Bourne shell command:
$ XENVIRONMENT=Xapp xrun

14.7Summary
In this chapter we have looked at an object-oriented design for a simple calculator with a graphical user interface. The CRC design technique summarized at the end of section 14.3 leads to some classes that can be reused unchanged for each of the three solutions.

14.8Exercises

189



The first solution tests the actual calculator without a graphical interface. Here, the encapsulation as a class permits an easy test setup. Once the calculator class is functional we can concentrate solely on the idiosyncrasies of the graphics libraries imposed upon us.
Both, curses and X11 require that we design some wrapper classes to merge the external library with our class hierarchy. The curses example demonstrates that without message forwarding we have to compromise: wrappers that are more likely reusable for the next project do not function too well in conjunction with an existing, application-oriented class hierarchy; wrappers that mesh well with our problem know too much about it to be generally reusable for dealing with curses.
The X11 solution shows the convenience of message forwarding. Wrappers just about completely hide the internals of X11 and the toolkit widgets. Problem- oriented classes like XButton combine the necessary functionality from the wrappers with the Ic class developed for our calculator. Message forwarding lets classes like XButton function as if they were descendants of Ic. In this example, message forwarding permits objects to act as if they belonged to two classes at the same time, but we do not incur the overhead and complexity of multiple inheri- tance as supported in C++.
Message forwarding is quite simple to implement. All that needs to be done is to modify the selector generation in the appropriate ooc reports to redirect non- understood selector calls to a new dynamically linked method forward() which classes like XButton overwrite to receive and possibly redirect forwarded mes- sages.

14.8 Exercises
Obviously, wrapping curses into a suitable class hierarchy is an interesting exercise for character terminal aficionados. Similarly, our X11 calculator experiment can be redone with OSF/Motif or another toolkit.
Using accelerators is perhaps not the most natural way to map key presses into input to our calculators. One would probably think of action functions first. How- ever, it turns out that while an action function knows the widget it applies to, it has no reasonable way to get from the widget to our wrapper. Either somebody recom- piles the X toolkit with an extra pointer for user data in the Object instance record, or we have to subclass some toolkit widgets to provide just such a pointer. Given the pointer, however, we can create a powerful technology based on action func- tions and our gate().
The idea to gate() and wire() was more or less lifted from NeXTSTEP. How- ever, in NeXTSTEP a class can have more than one outlet, i.e., pointer to another object, and during wiring both, the actual outlet and the method to be used at the receiving end, can be specified.
Comparing sections 5.5 and 11.4, we can see that Var should really inherit from
Node and Symbol. Using forward(), we could avoid Val and its subclasses.
