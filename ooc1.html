Abstract Data Types Information Hiding


1.1Data Types
Data types are an integral part of every programming language. ANSI-C has int, double and char to name just a few. Programmers are rarely content with what’s available and a programming language normally provides facilities to build new data types from those that are predefined. A simple approach is to form aggregates such as arrays, structures, or unions. Pointers, according to C. A. R. Hoare ‘‘a step from which we may never recover,’’ permit us to represent and manipulate data of essentially unlimited complexity.
What exactly is a data type? We can take several points of view. A data type is a set of values — char typically has 256 distinct values, int has many more; both are evenly spaced and behave more or less like the natural numbers or integers of mathematics. double once again has many more values, but they certainly do not behave like mathematics’ real numbers.
Alternatively, we can define a data type as a set of values plus operations to work with them. Typically, the values are what a computer can represent, and the operations more or less reflect the available hardware instructions. int in ANSI-C does not do too well in this respect: the set of values may vary between machines, and operations like arithmetic right shift may behave differently.
More complicated examples do not fare much better. Typically we would define an element of a linear list as a structure
typedef struct node { struct node * next;
... information ...
} node;
and for the operations we specify function headers like
node * head (node * elt, const node * tail);
This approach, however, is quite sloppy. Good programming principles dictate that we conceal the representation of a data item and declare only the possible manipulations.

1.2Abstract Data Types
We call a data type abstract , if we do not reveal its representation to the user. At a theoretical level this requires us to specify the properties of the data type by mathematical axioms involving the possible operations. For example, we can remove an element from a queue only as often as we have added one previously, and we retrieve the elements in the same order in which they were added.


Abstract data types offer great flexibility to the programmer. Since the representation is not part of the definition, we are free to choose whatever is easi- est or most efficient to implement. If we manage to distribute the necessary infor- mation correctly, use of the data type and our choice of implementation are totally independent.
Abstract data types satisfy the good programming principles of information hid- ing and divide and conquer. Information such as the representation of data items is given only to the one with a need to know: to the implementer and not to the user. With an abstract data type we cleanly separate the programming tasks of imple- mentation and usage: we are well on our way to decompose a large system into smaller modules.

1.3An Example — Set
So how do we implement an abstract data type? As an example we consider a set of elements with the operations add, find, and drop.* They all apply to a set and an element and return the element added to, found in, or removed from a set. find can be used to implement a condition contains which tells us whether an element is already contained in a set.
Viewed this way, set is an abstract data type. To declare what we can do with a set, we start a header file Set.h:
#ifndef SET_H #define SET_H
extern const void * Set;
void * add (void * set, const void * element);
void * find (const void * set, const void * element); void * drop (void * set, const void * element);
int contains (const void * set, const void * element); #endif
The preprocessor statements protect the declarations: no matter how many times
we include Set.h, the C compiler only sees the declarations once. This technique of protecting header files is so standard, that the GNU C preprocessor recognizes it and does not even access such a file when its protecting symbol is defined.
Set.h is complete, but is it useful? We can hardly reveal or assume less: Set will have to somehow represent the fact, that we are working with sets; add() takes an element, adds it to a set, and returns whatever was added or already present in the set; find() looks for an element in a set and returns whatever is present in the set or a null pointer; drop() locates an element, removes it from a set, and returns whatever was removed; contains() converts the result of find() into a truth value.


* Unfortunately, remove is an ANSI-C library function to remove a file. If we used this name for a set function, we could no longer include stdio.h.

1.4Memory Management	3

The generic pointer void * is used throughout. On the one hand it makes it impossible to discover what a set looks like, but on the other hand it permits us to pass virtually anything to add() and the other functions. Not everything will behave like a set or an element — we are sacrificing type security in the interest of informa- tion hiding. However, we will see in chapter 8 that this approach can be made completely secure.

1.4Memory Management
We may have overlooked something: how does one obtain a set? Set is a pointer, not a type defined by typedef; therefore, we cannot define local or global variables of type Set. Instead, we are only going to use pointers to refer to sets and ele- ments, and we declare source and sink of all data items in new.h:
void * new (const void * type, ...); void delete (void * item);
Just like Set.h this file is protected by a preprocessor symbol NEW_H. The text only shows the interesting parts of each new file, the source diskette contains the com- plete code of all examples.
new() accepts a descriptor like Set and possibly more arguments for initializa- tion and returns a pointer to a new data item with a representation conforming to the descriptor. delete() accepts a pointer originally produced by new() and recycles the associated resources.
new() and delete() presumably are a frontend to the ANSI-C functions calloc() and free(). If they are, the descriptor has to indicate at least how much memory is required.

1.5Object
If we want to collect anything interesting in a set, we need another abstract data type Object described by the header file Object.h:
extern const void * Object;	/* new(Object); */ int differ (const void * a, const void * b);
differ() can compare objects: it returns true if they are not equal and false if they
are. This description leaves room for the functionality of strcmp(): for some pairs of objects we might choose to return a negative or positive value to specify an or- dering.
Real life objects need more functionality to do something useful. For the moment, we restrict ourselves to the bare necessities for membership in a set. If we built a bigger class library, we would see that a set — and in fact everything else — is an object, too. At this point, a lot of functionality results more or less for free.


1.6An Application
With the header files, i.e., the definitions of the abstract data types, in place we can write an application main.c:
#include <stdio.h>
#include "new.h" #include "Object.h" #include "Set.h"
int main ()
{	void * s = new(Set);
void * a = add(s, new(Object)); void * b = add(s, new(Object)); void * c = new(Object);
if (contains(s, a) && contains(s, b)) puts("ok");
if (contains(s, c)) puts("contains?");
if (differ(a, add(s, a)))
puts("differ?");
if (contains(s, drop(s, a)))
puts("drop?");
delete(drop(s, b));
delete(drop(s, c));
return 0;
}
We create a set and add two new objects to it. If all is well, we find the objects in the set and we should not find another new object. The program should simply print ok.
The call to differ() illustrates a semantic point: a mathematical set can only contain one copy of the object a; an attempt to add it again must return the original object and differ() ought to be false. Similarly, once we remove the object, it should no longer be in the set.
Removing an element not in a set will result in a null pointer being passed to delete(). For now, we stick with the semantics of free() and require this to be acceptable.

1.7An Implementation — Set
main.c will compile successfully, but before we can link and execute the program, we must implement the abstract data types and the memory manager. If an object stores no information and if every object belongs to at most one set, we can represent each object and each set as small, unique, positive integer values used as indices into an array heap[]. If an object is a member of a set, its array element con- tains the integer value representing the set. Objects, therefore, point to the set containing them.

1.7An Implementation — ‘‘Set’’	5

This first solution is so simple that we combine all modules into a single file Set.c. Sets and objects have the same representation, so new() pays no attention to the type description. It only returns an element in heap[] with value zero:
#if ! defined MANY || MANY < 1 #define MANY	10
#endif
static int heap [MANY];
void * new (const void * type,	)
{	int * p;	/* & heap[1..] */
for (p = heap + 1; p < heap + MANY; ++ p) if (! * p)
break;
assert(p < heap + MANY);
* p = MANY;
return p;
}
We use zero to mark available elements of heap[]; therefore, we cannot return a reference to heap[0] — if it were a set, its elements would contain the index value zero.
Before an object is added to a set, we let it contain the impossible index value MANY so that new() cannot find it again and we still cannot mistake it as a member of any set.
new() can run out of memory. This is the first of many errors, that ‘‘cannot happen’’. We will simply use the ANSI-C macro assert() to mark these points. A more realistic implementation should at least print a reasonable error message or use a general function for error handling which the user may overwrite. For our pur- pose of developing a coding technique, however, we prefer to keep the code uncluttered. In chapter 13 we will look at a general technique for handling excep- tions.
delete() has to be careful about null pointers. An element of heap[] is recycled by setting it to zero:
void delete (void * _item)
{	int * item = _item;
if (item)
{	assert(item > heap && item < heap + MANY);
* item = 0;
}
}
We need a uniform way to deal with generic pointers; therefore, we prefix their names with an underscore and only use them to initialize local variables with the desired types and with the appropriate names.
A set is represented in its objects: each element points to the set. If an ele- ment contains MANY, it can be added to the set, otherwise, it should already be in the set because we do not permit an object to belong to more than one set.


void * add (void * _set, const void * _element)
{	int * set = _set;
const int * element = _element;
assert(set > heap && set < heap + MANY); assert(* set == MANY);
assert(element > heap && element < heap + MANY);
if (* element == MANY)
* (int *) element = set — heap;
else
assert(* element == set — heap);
return (void *) element;
}
assert() takes out a bit of insurance: we would only like to deal with pointers into heap[] and the set should not belong to some other set, i.e., its array element value ought to be MANY.
The other functions are just as simple. find() only looks if its element contains the proper index for the set:
void * find (const void * _set, const void * _element)
{	const int * set = _set;
const int * element = _element;
assert(set > heap && set < heap + MANY); assert(* set == MANY);
assert(element > heap && element < heap + MANY); assert(* element);
return * element == set — heap ? (void *) element : 0;
}
contains() converts the result of find() into a truth value:
int contains (const void * _set, const void * _element)
{
return find(_set, _element) != 0;
}
drop() can rely on find() to check if the element to be dropped actually belongs to the set. If so, we return it to object status by marking it with MANY:
void * drop (void * _set, const void * _element)
{	int * element = find(_set, _element);
if (element)
* element = MANY; return element;
}
If we were pickier, we could insist that the element to be dropped not belong to another set. In this case, however, we would replicate most of the code of find() in drop().
Our implementation is quite unconventional. It turns out that we do not need differ() to implement a set. We still need to provide it, because our application uses this function.

1.8Another Implementation — ‘‘Bag’’	7
int differ (const void * a, const void * b)
{
return a != b;
}
Objects differ exactly when the array indices representing them differ, i.e., a simple pointer comparison is sufficient.
We are done — for this solution we have not used the descriptors Set and
Object but we have to define them to keep our C compiler happy:
const void * Set; const void * Object;
We did use these pointers in main() to create new sets and objects.

1.8Another Implementation — Bag
Without changing the visible interface in Set.h we can change the implementation. This time we use dynamic memory and represent sets and objects as structures:
struct Set { unsigned count; };
struct Object { unsigned count; struct Set * in; };
count keeps track of the number of elements in a set. For an element, count records how many times this element has been added to the set. If we decrement count each time the element is passed to drop() and only remove the element once count is zero, we have a Bag, i.e., a set where elements have a reference count.
Since we will use dynamic memory to represent sets and objects, we need to initialize the descriptors Set and Object so that new() can find out how much memory to reserve:
static const size_t _Set = sizeof(struct Set); static const size_t _Object = sizeof(struct Object);
const void * Set = & _Set;
const void * Object = & _Object;
new() is now much simpler:
void * new (const void * type, ...)
{	const size_t size = * (const size_t *) type; void * p = calloc(1, size);
assert(p); return p;
}
delete() can pass its argument directly to free() — in ANSI-C a null pointer may be passed to free().
add() has to more or less believe its pointer arguments. It increments the element’s reference counter and the number of elements in the set:


void * add (void * _set, const void * _element)
{	struct Set * set = _set;
struct Object * element = (void *) _element;
assert(set); assert(element);
if (! element —> in) element —> in = set;
else
assert(element —> in == set);
++ element —> count, ++ set —> count;
return element;
}
find() still checks, if the element points to the appropriate set:
void * find (const void * _set, const void * _element)
{	const struct Object * element = _element;
assert(_set); assert(element);
return element —> in == _set ? (void *) element : 0;
}
contains() is based on find() and remains unchanged.
If drop() finds its element in the set, it decrements the element’s reference count and the number of elements in the set. If the reference count reaches zero, the element is removed from the set:
void * drop (void * _set, const void * _element)
{	struct Set * set = _set;
struct Object * element = find(set, _element);
if (element)
{	if (—— element —> count == 0) element —> in = 0;
—— set —> count;
}
return element;
}
We can now provide a new function count() which returns the number of ele- ments in a set:
unsigned count (const void * _set)
{	const struct Set * set = _set;
assert(set);
return set —> count;
}
Of course, it would be simpler to let the application read the component .count directly, but we insist on not revealing the representation of sets. The overhead of a function call is insignificant compared to the danger of an application being able to overwrite a critical value.

1.9Summary	9

Bags behave differently from sets: an element can be added several times; it will only disappear from the set, once it is dropped as many times as it was added. Our application in section 1.6 added the object a twice to the set. After it is dropped from the set once, contains() will still find it in the bag. The test program now has the output
ok drop?

1.9Summary
For an abstract data type we completely hide all implementation details, such as the representation of data items, from the application code.
The application code can only access a header file where a descriptor pointer represents the data type and where operations on the data type are declared as functions accepting and returning generic pointers.
The descriptor pointer is passed to a general function new() to obtain a pointer to a data item, and this pointer is passed to a general function delete() to recycle the associated resources.
Normally, each abstract data type is implemented in a single source file. Ideally, it has no access to the representation of other data types. The descriptor pointer normally points at least to a constant size_t value indicating the space requirements of a data item.

1.10Exercises
If an object can belong to several sets simultaneously, we need a different representation for sets. If we continue to represent objects as small unique integer values, and if we put a ceiling on the number of objects available, we can represent a set as a bitmap stored in a long character string, where a bit selected by the object value is set or cleared depending on the presence of the object in the set.
A more general and more conventional solution represents a set as a linear list of nodes storing the addresses of objects in the set. This imposes no restriction on objects and permits a set to be implemented without knowing the representation of an object.
For debugging it is very helpful to be able to look at individual objects. A rea- sonably general solution are two functions
int store (const void * object, FILE * fp); int storev (const void * object, va_list ap);
store() writes a description of the object to the file pointer. storev() uses va_arg() to retrieve the file pointer from the argument list pointed to by ap. Both functions return the number of characters written. storev() is practical if we implement the following function for sets:
int apply (const void * set,
int (* action) (void * object, va_list ap), ...);


apply() calls action() for each element in set and passes the rest of the argument list. action() must not change set but it may return zero to terminate apply() early. apply() returns true if all elements were processed.

